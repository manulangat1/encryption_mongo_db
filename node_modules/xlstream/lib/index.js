"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }
var __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.excelNumberFormat = exports.getWorksheets = exports.getXlsxStreams = exports.getXlsxStream = void 0;
var numfmt = require('numfmt');
var fclone_1 = __importDefault(require("fclone"));
var path_1 = __importDefault(require("path"));
var ssf_1 = __importDefault(require("ssf"));
var stream_1 = require("stream");
var StreamZip = require('node-stream-zip');
var saxStream = require('sax-stream');
var rename = require('deep-rename-keys');
var currentSheetProcessedSize = 0;
var currentSheetSize = 0;
function lettersToNumber(letters) {
    return letters.split('').reduce(function (r, a) { return r * 26 + parseInt(a, 36) - 9; }, 0);
}
function numbersToLetter(number) {
    var colName = '';
    var dividend = Math.floor(Math.abs(number));
    var rest;
    while (dividend > 0) {
        rest = (dividend - 1) % 26;
        colName = String.fromCharCode(65 + rest) + colName;
        dividend = parseInt("" + (dividend - rest) / 26);
    }
    return colName;
}
;
function applyHeaderToObj(obj, header) {
    if (!header || !header.length) {
        return obj;
    }
    var newObj = {};
    for (var _i = 0, _a = Object.keys(obj); _i < _a.length; _i++) {
        var columnName = _a[_i];
        var index = lettersToNumber(columnName) - 1;
        newObj[header[index] || "[" + columnName + "]"] = obj[columnName];
    }
    return newObj;
}
function getFilledHeader(arr, header) {
    if (!header || !header.length) {
        return header;
    }
    var filledHeader = [];
    for (var i = 0; i < Math.max(arr.length, header.length); i++) {
        filledHeader.push(header[i] ? header[i] : "[" + numbersToLetter(i + 1) + "]");
    }
    return filledHeader;
}
function fillMergedCells(dict, currentRowName, arr, obj, formattedArr, formattedObj) {
    for (var _i = 0, _a = Object.keys(dict[currentRowName]); _i < _a.length; _i++) {
        var columnName = _a[_i];
        var parentCell = dict[currentRowName][columnName].parent;
        var index = lettersToNumber(columnName) - 1;
        arr[index] = obj[columnName] = dict[parentCell.row][parentCell.column].value.raw;
        formattedArr[index] = formattedObj[columnName] = dict[parentCell.row][parentCell.column].value.formatted;
    }
}
function formatNumericValue(attr, value) {
    if (attr === 'inlineStr' || attr === 's') {
        return value;
    }
    return isNaN(value) ? value : Number(value);
}
function getTransform(formats, strings, dict, withHeader, ignoreEmpty, numberFormat) {
    var lastReceivedRow = 0;
    var header = [];
    return new stream_1.Transform({
        objectMode: true,
        transform: function (chunk, encoding, done) {
            var _a, _b, _c, _d, _e;
            var arr = [];
            var formattedArr = [];
            var obj = {};
            var formattedObj = {};
            var record = rename(fclone_1.default(chunk.record), function (key) {
                var keySplit = key.split(':');
                var tag = keySplit.length === 2 ? keySplit[1] : key;
                return tag;
            });
            var children = record.children ? record.children.c.length ? record.children.c : [record.children.c] : [];
            var nextRow = record.attribs ? parseInt(record.attribs.r) : lastReceivedRow + 1;
            if (!ignoreEmpty) {
                var emptyRowCount = nextRow - lastReceivedRow - 1;
                for (var i = 0; i < emptyRowCount; i++) {
                    this.push({
                        raw: {
                            obj: {},
                            arr: []
                        },
                        formatted: {
                            obj: {},
                            arr: []
                        },
                        header: getFilledHeader(arr, header),
                        processedSheetSize: currentSheetProcessedSize,
                        totalSheetSize: currentSheetSize,
                    });
                }
            }
            lastReceivedRow = nextRow;
            for (var i = 0; i < children.length; i++) {
                var ch = children[i];
                if (ch.children) {
                    var value = void 0;
                    var type = (_a = ch.attribs) === null || _a === void 0 ? void 0 : _a.t;
                    var columnName = (_b = ch.attribs) === null || _b === void 0 ? void 0 : _b.r;
                    var formatId = ((_c = ch.attribs) === null || _c === void 0 ? void 0 : _c.s) ? Number(ch.attribs.s) : 0;
                    if (type === 'inlineStr') {
                        value = ch.children.is.children.t.value;
                    }
                    else {
                        value = ch.children.v.value;
                        if (type === 's') {
                            value = strings[value];
                        }
                    }
                    value = formatNumericValue(type, value);
                    var column = columnName ? columnName.replace(/[0-9]/g, '') : numbersToLetter(i + 1);
                    var index = lettersToNumber(column) - 1;
                    if ((_d = dict === null || dict === void 0 ? void 0 : dict[lastReceivedRow]) === null || _d === void 0 ? void 0 : _d[column]) {
                        dict[lastReceivedRow][column].value.raw = value;
                    }
                    arr[index] = value;
                    obj[column] = value;
                    if (formatId) {
                        var numFormat = formats[formatId];
                        if (numberFormat && numberFormat === 'excel' && typeof numFormat === 'number' && exports.excelNumberFormat[numFormat]) {
                            numFormat = exports.excelNumberFormat[numFormat];
                        }
                        else if (numberFormat && typeof numberFormat === 'object') {
                            numFormat = numberFormat[numFormat];
                        }
                        if (typeof numFormat === 'string') {
                            value = numfmt.format(numFormat, value);
                        }
                        else {
                            value = ssf_1.default.format(numFormat, value);
                        }
                        value = formatNumericValue(type, value);
                    }
                    if ((_e = dict === null || dict === void 0 ? void 0 : dict[lastReceivedRow]) === null || _e === void 0 ? void 0 : _e[column]) {
                        dict[lastReceivedRow][column].value.formatted = value;
                    }
                    formattedArr[index] = value;
                    formattedObj[column] = value;
                }
            }
            if (dict === null || dict === void 0 ? void 0 : dict[lastReceivedRow]) {
                fillMergedCells(dict, lastReceivedRow, arr, obj, formattedArr, formattedObj);
            }
            if (((typeof withHeader === 'number' && withHeader === lastReceivedRow - 1) || (typeof withHeader !== 'number' && withHeader)) && !header.length) {
                var _loop_1 = function (i) {
                    var hasDuplicate = arr.filter(function (x) { return x === arr[i]; }).length > 1;
                    header[i] = hasDuplicate ? "[" + numbersToLetter(i + 1) + "] " + arr[i] : arr[i];
                };
                for (var i = 0; i < arr.length; i++) {
                    _loop_1(i);
                }
                done();
            }
            else {
                done(undefined, ignoreEmpty && !arr.length ? null : {
                    raw: {
                        obj: applyHeaderToObj(obj, header),
                        arr: arr
                    },
                    formatted: {
                        obj: applyHeaderToObj(formattedObj, header),
                        arr: formattedArr,
                    },
                    header: getFilledHeader(arr, header),
                    processedSheetSize: currentSheetProcessedSize,
                    totalSheetSize: currentSheetSize,
                });
            }
        },
        flush: function (callback) {
            if (dict) {
                var unprocessedRows = Object.keys(dict).map(function (x) { return Number(x); }).filter(function (x) { return x > lastReceivedRow; });
                for (var _i = 0, unprocessedRows_1 = unprocessedRows; _i < unprocessedRows_1.length; _i++) {
                    var unprocessedRow = unprocessedRows_1[_i];
                    var arr = [];
                    var formattedArr = [];
                    var obj = {};
                    var formattedObj = {};
                    fillMergedCells(dict, unprocessedRow, arr, obj, formattedArr, formattedObj);
                    this.push((ignoreEmpty && !arr.length) ? null : {
                        raw: {
                            obj: applyHeaderToObj(obj, header),
                            arr: arr
                        },
                        formatted: {
                            obj: applyHeaderToObj(formattedObj, header),
                            arr: formattedArr,
                        },
                        header: getFilledHeader(arr, header),
                        processedSheetSize: currentSheetProcessedSize,
                        totalSheetSize: currentSheetSize,
                    });
                }
            }
            callback();
        }
    });
}
function getXlsxStream(options) {
    return __awaiter(this, void 0, void 0, function () {
        var generator, stream;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    generator = getXlsxStreams({
                        filePath: options.filePath,
                        encoding: options.encoding,
                        sheets: [{
                                id: options.sheet,
                                withHeader: options.withHeader,
                                ignoreEmpty: options.ignoreEmpty,
                                fillMergedCells: options.fillMergedCells,
                                numberFormat: options.numberFormat,
                            }]
                    });
                    return [4 /*yield*/, generator.next()];
                case 1:
                    stream = _a.sent();
                    return [2 /*return*/, stream.value];
            }
        });
    });
}
exports.getXlsxStream = getXlsxStream;
function getXlsxStreams(options) {
    return __asyncGenerator(this, arguments, function getXlsxStreams_1() {
        function setupGenericData() {
            return new Promise(function (resolve, reject) {
                function processSharedStrings(numberFormats, formats) {
                    for (var i = 0; i < formats.length; i++) {
                        var format = numberFormats[formats[i]];
                        if (format) {
                            formats[i] = format;
                        }
                    }
                    zip.stream('xl/sharedStrings.xml', function (err, stream) {
                        if (stream) {
                            if (options.encoding) {
                                stream.setEncoding(options.encoding);
                            }
                            stream.pipe(saxStream({
                                strict: true,
                                tag: ['x:si', 'si']
                            })).on('data', function (x) {
                                var record = x.record;
                                if (record.children.t) {
                                    strings.push(record.children.t.value);
                                }
                                else if (!record.children.r.length) {
                                    strings.push(record.children.r.children.t.value);
                                }
                                else {
                                    var str = '';
                                    for (var i = 0; i < record.children.r.length; i++) {
                                        str += record.children.r[i].children.t.value;
                                    }
                                    strings.push(str);
                                }
                            });
                            stream.on('end', function () {
                                resolve();
                            });
                        }
                        else {
                            resolve();
                        }
                    });
                }
                function processStyles() {
                    zip.stream("xl/styles.xml", function (err, stream) {
                        if (stream) {
                            if (options.encoding) {
                                stream.setEncoding(options.encoding);
                            }
                            stream.pipe(saxStream({
                                strict: true,
                                tag: ['x:cellXfs', 'x:numFmts', 'cellXfs', 'numFmts']
                            })).on('data', function (x) {
                                var _a, _b, _c;
                                if ((x.tag === 'numFmts' || x.tag === 'x:numFmts') && x.record.children) {
                                    var numFmtField = x.record.children['x:numFmt'] ? 'x:numFmt' : 'numFmt';
                                    var children = x.record.children[numFmtField].length ? x.record.children[numFmtField] : [x.record.children[numFmtField]];
                                    for (var i = 0; i < children.length; i++) {
                                        numberFormats[Number(children[i].attribs.numFmtId)] = children[i].attribs.formatCode;
                                    }
                                }
                                else if ((x.tag === 'cellXfs' || x.tag === 'x:cellXfs') && x.record.children) {
                                    var xfField = x.record.children['x:xf'] ? 'x:xf' : 'xf';
                                    for (var i = 0; i < x.record.children[xfField].length; i++) {
                                        var ch = x.record.children[xfField][i];
                                        if ((_a = ch.attribs) === null || _a === void 0 ? void 0 : _a.numFmtId) {
                                            formats[i] = ((_b = ch.attribs) === null || _b === void 0 ? void 0 : _b.numFmtId) ? Number((_c = ch.attribs) === null || _c === void 0 ? void 0 : _c.numFmtId) : '';
                                        }
                                    }
                                }
                            });
                            stream.on('end', function () {
                                processSharedStrings(numberFormats, formats);
                            });
                        }
                        else {
                            processSharedStrings(numberFormats, formats);
                        }
                    });
                }
                function processWorkbook() {
                    zip.stream('xl/workbook.xml', function (err, stream) {
                        if (options.encoding) {
                            stream.setEncoding(options.encoding);
                        }
                        stream.pipe(saxStream({
                            strict: true,
                            tag: ['x:sheet', 'sheet']
                        })).on('data', function (x) {
                            var attribs = x.record.attribs;
                            sheets.push({ name: attribs.name, relsId: attribs['r:id'] });
                        });
                        stream.on('end', function () {
                            processStyles();
                        });
                    });
                }
                function getRels() {
                    zip.stream('xl/_rels/workbook.xml.rels', function (err, stream) {
                        if (options.encoding) {
                            stream.setEncoding(options.encoding);
                        }
                        stream.pipe(saxStream({
                            strict: true,
                            tag: ['x:Relationship', 'Relationship']
                        })).on('data', function (x) {
                            rels[x.record.attribs.Id] = path_1.default.basename(x.record.attribs.Target);
                        });
                        stream.on('end', function () {
                            processWorkbook();
                        });
                    });
                }
                zip.on('ready', function () {
                    zipEntries = zip.entries();
                    getRels();
                });
                zip.on('error', function (err) {
                    reject(new Error(err));
                });
            });
        }
        function getMergedCellDictionary(sheetFileName) {
            return new Promise(function (resolve, reject) {
                zip.stream("xl/worksheets/" + sheetFileName, function (err, stream) {
                    if (options.encoding) {
                        stream.setEncoding(options.encoding);
                    }
                    var dict = {};
                    var readStream = stream
                        .pipe(saxStream({
                        strict: true,
                        tag: ['x:mergeCell', 'mergeCell']
                    }));
                    readStream.on('end', function () {
                        resolve(dict);
                    });
                    readStream.on('data', function (a) {
                        var record = a.record;
                        var mergedCellRange = record.attribs.ref;
                        var mergedCellRangeSplit = mergedCellRange.split(':');
                        var mergedCellRangeStart = mergedCellRangeSplit[0];
                        var mergedCellRangeEnd = mergedCellRangeSplit[1];
                        var columnLetterStart = mergedCellRangeStart.replace(/[0-9]/g, '');
                        var columnNumberStart = lettersToNumber(columnLetterStart);
                        var rowNumberStart = Number(mergedCellRangeStart.replace(columnLetterStart, ''));
                        var columnLetterEnd = mergedCellRangeEnd.replace(/[0-9]/g, '');
                        var columnNumberEnd = lettersToNumber(columnLetterEnd);
                        var rowNumberEnd = Number(mergedCellRangeEnd.replace(columnLetterEnd, ''));
                        for (var rowNumber = rowNumberStart; rowNumber <= rowNumberEnd; rowNumber++) {
                            for (var columnNumber = columnNumberStart; columnNumber <= columnNumberEnd; columnNumber++) {
                                var columnLetter = numbersToLetter(columnNumber);
                                if (!dict[rowNumber]) {
                                    dict[rowNumber] = {};
                                }
                                dict[rowNumber][columnLetter] = {
                                    parent: {
                                        column: columnLetterStart,
                                        row: rowNumberStart,
                                    },
                                    value: { formatted: null, raw: null },
                                };
                            }
                        }
                    });
                    readStream.resume();
                });
            });
        }
        function getSheetTransform(sheetFileName, withHeader, ignoreEmpty, fillMergedCells, numberFormat) {
            return __awaiter(this, void 0, void 0, function () {
                var dict;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!fillMergedCells) return [3 /*break*/, 2];
                            return [4 /*yield*/, getMergedCellDictionary(sheetFileName)];
                        case 1:
                            dict = _a.sent();
                            _a.label = 2;
                        case 2: return [2 /*return*/, new Promise(function (resolve, reject) {
                                var sheetFullFileName = "xl/worksheets/" + sheetFileName;
                                zip.stream(sheetFullFileName, function (err, stream) {
                                    if (options.encoding) {
                                        stream.setEncoding(options.encoding);
                                    }
                                    currentSheetProcessedSize = 0;
                                    currentSheetSize = zipEntries[sheetFullFileName].size;
                                    var readStream = stream
                                        .pipe(new stream_1.Transform({
                                        transform: function (chunk, encoding, done) {
                                            currentSheetProcessedSize += chunk.length;
                                            done(undefined, chunk);
                                        }
                                    }))
                                        .pipe(saxStream({
                                        strict: true,
                                        tag: ['x:row', 'row']
                                    }))
                                        .pipe(getTransform(formats, strings, dict, withHeader, ignoreEmpty, numberFormat));
                                    readStream.on('end', function () {
                                        if (currentSheetIndex + 1 === options.sheets.length) {
                                            zip.close();
                                        }
                                    });
                                    resolve(readStream);
                                });
                            })];
                    }
                });
            });
        }
        var sheets, rels, numberFormats, formats, strings, zip, zipEntries, currentSheetIndex, _loop_2;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    sheets = [];
                    rels = {};
                    numberFormats = {};
                    formats = [];
                    strings = [];
                    zip = new StreamZip({
                        file: options.filePath,
                        storeEntries: true
                    });
                    zipEntries = {};
                    currentSheetIndex = 0;
                    return [4 /*yield*/, __await(setupGenericData())];
                case 1:
                    _a.sent();
                    _loop_2 = function () {
                        var sheet, id, sheetIndex, sheetFileName, transform;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    sheet = options.sheets[currentSheetIndex];
                                    id = sheet.id;
                                    sheetIndex = 0;
                                    if (typeof id === 'number') {
                                        sheetIndex = id;
                                    }
                                    else if (typeof id === 'string') {
                                        sheetIndex = sheets.findIndex(function (x) { return x.name === id; });
                                    }
                                    sheetFileName = rels[sheets[sheetIndex].relsId];
                                    return [4 /*yield*/, __await(getSheetTransform(sheetFileName, sheet.withHeader, sheet.ignoreEmpty, sheet.fillMergedCells, sheet.numberFormat))];
                                case 1:
                                    transform = _a.sent();
                                    return [4 /*yield*/, __await(transform)];
                                case 2: return [4 /*yield*/, _a.sent()];
                                case 3:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    };
                    currentSheetIndex = 0;
                    _a.label = 2;
                case 2:
                    if (!(currentSheetIndex < options.sheets.length)) return [3 /*break*/, 5];
                    return [5 /*yield**/, _loop_2()];
                case 3:
                    _a.sent();
                    _a.label = 4;
                case 4:
                    currentSheetIndex++;
                    return [3 /*break*/, 2];
                case 5: return [2 /*return*/];
            }
        });
    });
}
exports.getXlsxStreams = getXlsxStreams;
function getWorksheets(options) {
    return new Promise(function (resolve, reject) {
        function processWorkbook() {
            zip.stream('xl/workbook.xml', function (err, stream) {
                if (options.encoding) {
                    stream.setEncoding(options.encoding);
                }
                if (err) {
                    reject(err);
                }
                stream.pipe(saxStream({
                    strict: true,
                    tag: ['x:sheet', 'sheet'],
                })).on('data', function (x) {
                    sheets.push({
                        name: x.record.attribs.name,
                        hidden: x.record.attribs.state && x.record.attribs.state === 'hidden' ? true : false,
                    });
                });
                stream.on('end', function () {
                    zip.close();
                    resolve(sheets);
                });
                stream.on('error', reject);
            });
        }
        var sheets = [];
        var zip = new StreamZip({
            file: options.filePath,
            storeEntries: true,
        });
        zip.on('ready', function () {
            processWorkbook();
        });
        zip.on('error', reject);
    });
}
exports.getWorksheets = getWorksheets;
exports.excelNumberFormat = {
    14: 'm/d/yyyy',
    22: 'm/d/yyyy h:mm',
    37: '#,##0_);(#,##0)',
    38: '#,##0_);[Red](#,##0)',
    39: '#,##0.00_);(#,##0.00)',
    40: '#,##0.00_);[Red](#,##0.00)',
    47: 'mm:ss.0',
};
